/* Задание 1. Реализуйте процесс-"эхо", который ожидает сообщения и 1) если получен атом
stop, то он заканчивает работу; 2) если получено {print, Term}, то выводит Term в
оболочке.
Для удобства использования модуль должен предоставлять интерфейс
echo:start() => ok
echo:print(Term) => ok
echo:stop() => ok
Пример работы:
> echo:start().
Started <0.33.0>
ok
> echo:print(1).
1
ok
> echo:print(stop).
stop
ok
> echo:stop().
Stopped!
Ok */

% Тут должно быть решение

% Тут должны быть запросы для проверки

/* Задание 2. Реализуйте модуль parent_children:
* start(N::integer()) запускает N+1 процесс: "родитель" и N "детей". Каждый из
детей ждёт сообщений. Если получено сообщение stop, процесс останавливается
без ошибки; если получено сообщение die, процесс падает с ошибкой; любое
другое сообщение печатается в оболочке. В случае, если один из детей умрёт с
ошибкой, родитель его перезапускает и печатает сообщение об этом. Если
родитель умирает, все дети тоже должны умереть.
* send_to_child(I::integer(), Msg::any()) посылает родителю сообщение, после
которого он пересылает Msg ребён

Параметр Options в задаче 3 всех вариантов -- список, который может содержать
следующие элементы: {sublist_size, integer()} (размер частей, на которые
разбивается список), {processes, integer()} (число процессов, которые
обрабатывают части списка), {timeout, Milliseconds::integer()|infinity}
(максимальное время, за которое функция должна закончить работу). При
отсутствии sublist_size в каждой части списка 1 элемент. При отсутствии processes
каждая часть обрабатывается отдельным процессом. Для работы с такими
списками можно использовать модуль proplists. */

% Тут должно быть решение

% Тут должны быть запросы для проверки

/* Заданиие 3. Реализуйте функцию par_partition(F, List, Options), которая возвращает пару
списков с теми же элементами, что lists:partition(F, List) (но не обязательно в том
же порядке). */

% Тут должно быть решение

% Тут должны быть запросы для проверки
