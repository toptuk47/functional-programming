/* Чтобы разобраться с различиями операторов =, ==, =:= и is, для каждого запроса сначала
попытайтесь
понять, как должен ответить Пролог, а потом проверьте, правильны ли ваши
предположения.
?- X = 1+2.
?- 3 = 1+2.
?- 2+1 = 1+2.
?- X == 1+2.
?- 3 == 1+2.
?- 2+1 == 1+2.
?- X =:= 1+2.
?- 3 =:= 1+2.
?- 2+1 =:= 1+2.
?- X is 1+2.
?- 3 is 1+2.
?- 2+1 is 1+2. */

/* Кроме того, в некоторых заданиях пригодятся предикаты проверки типов. Их можно
найти в разделе 4.5 (в новых версиях -- 4.6) помощи SWI-Prolog http://www.swi-
prolog.org/pldoc/doc_for?object=section%282,%274.6%27,swi%28%27/doc/Manual/typetest.ht
ml%27%29%29:
var(Term) -- удаётся для свободных переменных
nonvar(Term) -- противоположный var
float(Term) -- удаётся для чисел с плавающей точкой
integer(Term) -- удаётся для целых чисел
number(Term) -- удаётся для любых чисел
atom(Term) -- удаётся для атомов
compound(Term) -- удаётся для составных термов
atomic(Term) -- удаётся, если Term -- атом или число (или значение встроенного типа
"строка", который в нашем курсе не используется)
callable(Term) -- удаётся, если Term -- атом или составной терм
ground(Term) -- удаётся, если Term не содержит свободных переменных */

/* Задание 1. Определите (рекурсивно, не используя ^) предикат power(X, N, Power), который
выполняется, если Power -- число X в степени N.
?- power(3, 2, X).
X = 9 */

% Тут должно быть решение

% Тут должны быть запросы для проверки

/* Задание 2. Представим многочлены как списки их коэффициентов в порядке убывания
степени. Например, многочлен 2*x^2+1 будет представлен как [2,0,1]. Определите
предикат eval_poly(Polynom, X, Result), выполняющийся, если Result -- значение
многочлена Polynom при аргументе X. Для возведения в степень используйте
оператор ^ или определённый в прошлой задаче power/3. Возможно также
использование схемы Горнера.
?- eval_poly([2,0,1,0], 1, Result). % 2*X^3 + X = 2*1^3 + 1 = 3
Result = 3 */

% Тут должно быть решение

% Тут должны быть запросы для проверки

/* Задание 3. В числе операторов, определённых в Prolog, есть /\ (и), \/ (или), \+ (не) и ->
(следует). Определите предикат nnf(Formula), который выполняется, если Formula
-- формула, в которой отрицания стоят только перед переменными (переменные в
формуле представляем атомами).
?- nnf((x /\ (\+ y)) -> (\+ x) /\ z).
Yes
?- nnf((x /\ (\+ y)) -> \+ (x /\ z)).
No */

% Тут должно быть решение

% Тут должны быть запросы для проверки

/* Задание 4. Определите предикат nnf(Formula, NNF), который выполняется, если NNF --
формула, полученная из Formula эквивалентными преобразованиями, в которой
отрицания стоят только перед переменными.
?- nnf(\+ ((x -> y) /\ z), NNF).
NNF = (x /\ (\+ y)) \/ (\+ z) */

% Тут долнжо быть решение

% Тут должны быть запросы для проверки
